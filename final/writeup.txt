Ian Johnson
Idea: Minesweeper
4/27/2018

The joystick will move which square is selected, z clicks squares, and c sets flags / question marks.
The speaker will play a little sound effect when a flag is placed, and an explosion sound when a mine is activated.
The accelerometer is used to generate "random noise" which is used as the seed in the RNG to generate where the mines will be.
The LCD is used to actually see the game.

A challenge was implementing a cursor. When the joystick is moved, the tile where the cursor's at has to be redrawn, the cursor position updated, and then new cursor graphic data is drawn to the LCD.

Logic for drawing the right tile was also difficult. I had a high-level function that, depending on whether the tile had been clicked, flagged, was a mine tile, etc, would call f3d_lcd_drawTile with the correct parameters. f3d_lcd_drawTile was a function I added to the lcd driver to push big blocks of my tile data structure to the LCD via lcd_write16.

Graphics were added by hand as arrays of tiles, which were arrays of rows, which were arrays of 16bit values corresponding to the colors that would be drawn to the LCD. I designed the array this way so that whole rows could be pushed at a time. Properly initializing / passing a 3-dimensional array in C proved to be more difficult than expected, but I finally figured out how to do it. If I were to do this again I would probably just load all the graphics off the SD card as images.

The flood-fill style "find mines" function was also a bit of a challenge to implement, and I had to write / draw out a few sketches of it on paper to figure out the best way to do it. Basically, it keeps track of how many of the surrounding tiles are mines. For each of the adjacent tiles, if it's a mine, it adds to the count, but if it isn't it recursively calls the find mines function on that tile, while simultaneously keeping track of which tiles have already been processed. Once it gets back to the original tile, it'll draw the count. But with just this logic on its own, it would almost always get rid of every single non-mine square. So what I changed was, for when it checks each adjacent square except the first one, it won't recur unless the count is 0. This fixed the issue and made it feel more like real minesweeper.

There were still a couple glitches, like some unclicked tiles are drawn uncorrectly at times, but go back to looking how they should if you move the cursor over them and then move it off of them This also happens, albeit less often, with some numbered tiles. I don't consider this a huge deal as it wasn't game breaking. Another glitch I didn't have time to find the cause of is that sometimes you can win the game prematurely, or have all the mines sweeped and the game still won't tell you that you've won. The way I checked to see if the player's won the game is, at the start of the game, the number of squares is calculated by multiplying the lengths and widths of the board. Whenever a square is clicked, this variable is decremented. When the # of squares is equal to the # of mines, the player wins. Maybe this logic is incorrect, but I thought this is how I implemented it, and it still wasn't working correctly.

All in all, this project was really fun to work on (Despite the many constant annoyances and tests of patience with the nunchuks), I learned a lot, and it definitely increased my interest in Systems programming.
